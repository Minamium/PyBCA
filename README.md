# PyBCA
Brownian Cellular Automaton for Python

## Installation
```bash
git clone https://github.com/Minamium/PyBCA.git
pip install -e ./PyBCA
```

# 開発方針メモ

2次元のブラウン回路の動作をシミュレートするセルオートマトン. 状態は3状態で表す.


### cudaBCA
既存のセル空間と遷移規則を保存したyamlよりセル空間と遷移規則を読み込み, cuda上でシミュレーションを行うクラス.

特殊イベントとして, 任意セルの状態により任意セルを任意の状態に変更するイベントを定義できる機能も持つ.

また重要な機能として, 任意に新しい遷移規則を追加してC-JoinやCrossのエラーレートを表現できるようしなければならない.

### CellSpaceEditor
セル空間を編集するGUIアプリケーション. セル空間を表示し, 任意のセルを任意の状態に変更することができる.
またセル空間の更新の様子を確認するため, 任意ステップ数の更新後のセル空間の表示や, 1ステップ毎の更新を見れるよう, 連続更新も可能.

また, 範囲指定のコピーアンドペースト, Redo/Undo, セル空間の保存とロードを行う.

## セル空間の更新操作の検討

### セル空間 1 ステップ更新の実装仕様（CUDA/並列安全）

目的：**GPU（CUDA）上でセル並列**のまま、**ランダム性の公平性**と**トークン（状態=2）の増殖禁止**を同時に満たす 1 ステップ更新を定義する。  
状態は **4値**：`0 = Vacant`, `1 = Wire(信号線)`, `2 = Token`, `-1 = ReCycleBinとの接続点`。

ReCycleBinとは、理想的にトークンが十分に存在する領域であり、その接続点はトークンが出てきたり、また入っていく(回路上からは消える)動作を示す.
---

#### 入出力・前提

- **入力テンソル** `State`：セル空間 `[Trial, H, W]`（既定）。`dtype=uint8` 推奨（1セル=1B）。  
  - `Trial` は独立試行の本数（多数並列）。  
- **乱数**：**stateless**（例：Philox/SplitMix64）で `(seed, step, trial, y, x, salt)` から決定的生成。  
- **境界**：既定 **periodic**（トーラス）。回路設計上、境界依存は本質ではない。  
- **グローバル適用確率** `p_global ∈ [0,1]`。  
- **ルール種別**（YAML/JSON からコンパイル）  
  - `Move1` … **1トークン → 1セル** の移動。  
  - `Move2 (C-Join)` … **2トークン → 2セル同時** の移動（直交ペア等）。  
  - `prev/next` は **von Neumann（C/E/W/N/S）** で記述。回転対称はロード時に展開。

**不変条件（この仕様で常に成立）**
- **1 宛先 = 高々 1 採択**（競合解決済）  
- **1 出発元 = 高々 1 提案**（分裂禁止）  
- `Move2` は **2 宛先とも同一 move_id で同時採択**された時のみ成立（片落ち禁止）  
- よって **トークン総数は保存**（外生イベントを除く）

---

#### アルゴリズム（Push → Arbitrate → Commit の 3 段階）

##### 0) 近傍の前計算
- 各ステップ最初に **`roll` を 4 回だけ**実行し、`C, E, W, N, S` を取得（以降すべてで再利用）。

##### 1) 提案（Propose：全セル並列・読み取りのみ）
- **Move1（単独移動）**
  1. **出発元**：`State==2` で、移動先が `State==1`（線上）の方向を列挙（E/W/N/S、必要なら Stay）。  
  2. 乱数 `U < p_global` で **今ステップ動くか**を判定。  
  3. 動く場合、素子/配線の**方向重み**に基づき **カテゴリ乱択**で **高々 1 方向**を選ぶ（例：Gumbel-Top1）。  
  4. 1件の **提案レコード** を生成：  
     `move_id (u64)`, `src=(trial,y,x)`, `dst[0]=(trial,y',x')`, `priority`（乱数）。
- **Move2（C-Join：2トークン同時）**
  1. **アンカー**：中央 `State==0`。直交 2 方向に `State==2` が同時に存在するか検出。  
  2. 成立時に **1件の提案** として、**2つの出発元**と **2つの宛先**をペア保持：  
     `move_id`, `src[0], src[1]`, `dst[0], dst[1]`, `priority`（**両宛先で同じ**）。

> 実装メモ：CUDA では各スレッドが自セルを評価して即時に提案を書き出す。PyTorch ではブールマスク＋`roll`で `dst` ごとの要求ビットマップを構成。

##### 2) 競合解決（Arbitrate：宛先主導・並列）
- **宛先セルごと**に届いた提案の `(priority, move_id)` を比較し、**最大（or 最小）1件**のみ採択。  
  - CUDA：`uint64 ticket = (priority<<32) | move_id_low32; atomicMin(claim[dst], ticket)`。  
  - PyTorch：`scatter_reduce(..., reduce='amax')` 等で一括 `amax`。  
- **Move2 の確定条件**：**2 宛先とも同じ `move_id` が勝者**であること（AND 条件）。片方でも負けた提案は **両方不採用**。

##### 3) 確定反映（Commit：半同期・二重バッファ）
- `State_next ← State` を作成。採択セットのみ **ベクトル化更新**：
  - **Move1**：`State_next[src]=0`, `State_next[dst]=2`  
  - **Move2**：`State_next[src[0]]=0`, `State_next[src[1]]=0`, `State_next[dst[0]]=2`, `State_next[dst[1]]=2`  
- スワップ：`State ← State_next`。  
- **イベントフック**（任意）：確定後に外生イベント（任意セル→任意セル書換）を適用。

---

#### 乱数・公平性・再現性

- 乱数は用途別に 2 系統：
  1) **適用可否** `U_apply`：出発元ごとに `U_apply < p_global`。  
  2) **優先度** `priority`：提案ごとの公平な乱択順序エンコード（`argmin/argmax` で 1 件を選ぶ）。  
- `priority` は `(seed, step, trial, y, x, dir or pattern_id)` からのハッシュで生成 → **完全並列でも再現**。

> 直感：CPU の「候補をシャッフル→順に確率判定→最初の1件」≒  
> **（合格集合 ∧ 一様順）→ 最小 priority の 1 件**（統計的に同値）。

---

#### C-Join と単独移動の相互作用

- 両者は同じ **priority 空間**で仲裁されるため、同一宛先への衝突も**一貫したルール**で解決。  
- `Move2` は **両宛先で同一提案が勝者**の場合にのみ成立 → **同時移動の原子性**を保証。  
- この設計により **増殖なし／消滅なし** が維持される。

---

#### 計算量・メモリ・実装メモ

- **近傍 `roll`** は **各ステップ 4 回固定**（E/W/N/S）。ルール数に依らず一定。  
- 判定の主成分は **比較と論理積（AND）** で、**メモリ帯域支配**。  
- 宛先仲裁は **1 パスの amax**（CUDA 原子 or テンソル reduce）。  
- ルール数 `R ≤ 100` 規模なら、**方位テンプレ（直進/分岐/C-Join×4）**にまとめ、評価回数を圧縮可能。  
- 大量 `Trial` は **チャンク分割**で VRAM を制御し、統計のみ逐次吐き出し（JSONL 等）。  
- **CUDA 最適化**：共有メモリで 5 近傍タイル化、`uint8`/1bit 平面、カーネル融合、**CUDA Graph** で多ステップ起動を削減。

---

#### 例外・イベント処理

- **特殊イベント**（「任意セルの状態により任意セルを任意状態へ」）は **Commit 後**に適用。  
- CA の保存則と分離して故障注入・外生刺激を表現可能。

---

#### テスト観点（CI）

- **保存性**：イベント無効時、各ステップで `sum(State==2)` が不変。  
- **境界非依存**：中央領域で periodic/fixed の差が出ない（端を十分離す）。  
- **再現性**：固定 `seed` で CPU 実装と統計的一致（分布/FPT）または同アルゴリズム間のビット一致。  
- **C-Join 原子性**：片側のみ成立ケースで **不成立**、両側成立で **同時に成立**。

---

#### 実装モード（開発順）

1. **PyTorch 参照実装**  
   - `roll` 再利用 → 提案マスク → `scatter_reduce(amax)` で仲裁 → 逆方向 `roll` で出発元消去 → Commit。  
2. **CUDA 拡張（高速版）**  
   - **Kernel1**：近傍読取＋提案生成＋`atomicMin` による宛先クレーム  
   - **Kernel2**：クレーム結果を読んで Commit（`Move2` は両宛先チェック）  
   - **CUDA Graph** で 1000 ステップ単位をキャプチャし反復再生。

> 既存 WGPU の「ルール順 first-match」由来の偏りは、本仕様の **priority 仲裁**で解消される。
